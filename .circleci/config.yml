version: 2.1

orbs:
  aws-cli: circleci/aws-cli@5.1
  aws-ecr: circleci/aws-ecr@9.0
  # Terraform orb is no longer needed in this pipeline
  # terraform: circleci/terraform@3.7.0
anchors:
  - &context
    context:
      - circleci-secrets
jobs:
  build_and_deploy:
    parameters:
      environment:
        type: enum
        enum: ["staging", "production"]
        description: "The deployment environment (staging or production)."
    docker:
      - image: cimg/base:stable
    steps:
      - checkout # Checks out the Strapi code

      # Assume OIDC is configured in CircleCI Contexts
      - aws-cli/setup:
          aws-region: AWS_DEFAULT_REGION
          role-arn: ${AWS_OIDC_ROLE_ARN}
      
      # Step 1: Get the ECR repository URL from AWS Parameter Store
      - run:
          name: "Get ECR URL from Parameter Store"
          command: |
            INFRA_PATH="/strapi/<< parameters.environment >>"
            ENV_PATH="/strapi/<< parameters.environment >>/env"

            echo "Fetching infrastructure parameters from path: ${INFRA_PATH}"
            INFRA_PARAMS=$(aws ssm get-parameters-by-path --path "${INFRA_PATH}" --query "Parameters" --with-decryption)
            
            # Extract infrastructure details
            # DB_URL=$(echo "$INFRA_PARAMS" | jq -r '.[] | select(.Name | endswith("/db_url")) | .Value')
            ECR_URL=$(echo "$INFRA_PARAMS" | jq -r '.[] | select(.Name | endswith("/ecr-url")) | .Value')
            AWS_ECS_CLUSTER_NAME=$(echo "$INFRA_PARAMS" | jq -r '.[] | select(.Name | endswith("/ecs-cluster-name")) | .Value')
            AWS_ECS_SERVICE_NAME=$(echo "$INFRA_PARAMS" | jq -r '.[] | select(.Name | endswith("/ecs-service-name")) | .Value')

            if [ -z "$ECR_URL" ] || [ -z "$AWS_ECS_CLUSTER_NAME" ] || [ -z "$AWS_ECS_SERVICE_NAME" ]; then
              echo "One or more required infrastructure parameters were not found in SSM."
              exit 1
            fi
            
            ECR_REPO_NAME=$(echo "${ECR_URL}" | cut -d'/' -f2)
            
            echo "export ECR_REPOSITORY_NAME=${ECR_REPO_NAME}" >> $BASH_ENV
            # echo "export DB_URL=${DB_URL}" >> $BASH_ENV
            echo "export AWS_ECS_CLUSTER_NAME=${AWS_ECS_CLUSTER_NAME}" >> $BASH_ENV
            echo "export AWS_ECS_SERVICE_NAME=${AWS_ECS_SERVICE_NAME}" >> $BASH_ENV
            
            echo "Fetching application secrets from path: ${ENV_PATH}"
            ENV_PARAMS=$(aws ssm get-parameters-by-path --path "${ENV_PATH}" --query "Parameters" --with-decryption)

            # Create the .env file from application secrets
            echo "Creating .env file..."
            echo "$ENV_PARAMS" | jq -r '.[] | .Name |= sub("^(.*)/"; "") | "\(.Name)=\(.Value)"' > .env
            
            echo ".env file created with the following keys:"
            cut -d'=' -f1 .env
            
      - run:
          name: "Dynamically Fetch AWS Account ID"
          command: |
            # Get the caller identity from AWS and parse the Account ID with jq
            ACCOUNT_ID=$(aws sts get-caller-identity | jq -r '.Account')
            
            # Check if the Account ID was successfully fetched
            if [ -z "$ACCOUNT_ID" ]; then
              echo "Failed to get AWS Account ID."
              exit 1
            fi
            
            # Export the Account ID as an environment variable for the next steps
            echo "export AWS_ACCOUNT_ID=${ACCOUNT_ID}" >> $BASH_ENV
            echo "Successfully fetched AWS Account ID: ${ACCOUNT_ID}"
      - aws-ecr/ecr-login:
          registry-id: AWS_ACCOUNT_ID
      - aws-ecr/build-and-push-image:
          auth:
            - aws-cli/setup:
                aws-region: AWS_DEFAULT_REGION
                role-arn: ${AWS_OIDC_ROLE_ARN}
          region: AWS_DEFAULT_REGION
          registry-id: AWS_ACCOUNT_ID
          repo: "${ECR_REPOSITORY_NAME}"
          tag: "latest-<< parameters.environment >>-${CIRCLE_SHA1}"
          dockerfile: "Dockerfile.prod"
          no-output-timeout: "20m"

      # Step 3: Force a new deployment in the Fargate service
      - run:
          name: "Deploy to Fargate"
          command: |
            aws ecs update-service --cluster ${AWS_ECS_CLUSTER_NAME} \
              --service ${AWS_ECS_SERVICE_NAME} \
              --force-new-deployment

workflows:
  deploy:
    jobs:
      - build_and_deploy:
          name: deploy-staging
          environment: staging
          <<: *context
          filters:
            branches:
              only:
                - kyle 

      - build_and_deploy:
          name: deploy-production
          environment: production
          <<: *context
          filters:
            branches:
              only:
                - master 