version: 2.1

orbs:
  aws-cli: circleci/aws-cli@3.1.1
  aws-ecr: circleci/aws-ecr@8.2.1
  # Terraform orb is no longer needed in this pipeline
  # terraform: circleci/terraform@3.7.0
anchors:
  - &context
    context:
      - circleci-secrets
jobs:
  build_and_deploy:
    parameters:
      environment:
        type: enum
        enum: ["staging", "production"]
        description: "The deployment environment (staging or production)."
    docker:
      - image: cimg/base:stable
    steps:
      - checkout # Checks out the Strapi code

      # Assume OIDC is configured in CircleCI Contexts
      - aws-cli/setup:
          role-arn: ${AWS_OIDC_ROLE_ARN}
      
      # Step 1: Get the ECR repository URL from AWS Parameter Store
      - run:
          name: "Get ECR URL from Parameter Store"
          command: |
            INFRA_PATH="/strapi/<< parameters.environment >>/"
            ENV_PATH="/strapi/<< parameters.environment >>/env"

            echo "Fetching infrastructure parameters from path: ${INFRA_PATH}"
            INFRA_PARAMS=$(aws ssm get-parameters-by-path --path "${INFRA_PATH}" --query "Parameters" --with-decryption)
            
            # Extract infrastructure details
            DB_URL=$(echo "$PARAMETERS_JSON" | jq -r '.[] | select(.Name | endswith("/db_url")) | .Value')
            ECR_URL=$(echo "$INFRA_PARAMS" | jq -r '.[] | select(.Name | endswith("/ecr_url")) | .Value')
            AWS_ECS_CLUSTER_NAME=$(echo "$INFRA_PARAMS" | jq -r '.[] | select(.Name | endswith("/ecs_cluster_name")) | .Value')
            AWS_ECS_SERVICE_NAME=$(echo "$INFRA_PARAMS" | jq -r '.[] | select(.Name | endswith("/ecs_service_name")) | .Value')

            if [ -z "$ECR_URL" ] || [ -z "$CLUSTER_NAME" ] || [ -z "$SERVICE_NAME" ]; then
              echo "One or more required infrastructure parameters were not found in SSM."
              exit 1
            fi
            
            ECR_REPO_NAME=$(echo "${ECR_URL}" | cut -d'/' -f2)
            
            echo "export ECR_REPOSITORY_NAME=${ECR_REPO_NAME}" >> $BASH_ENV
            echo "export DB_URL=${DB_URL}" >> $BASH_ENV
            echo "export AWS_ECS_CLUSTER_NAME=${AWS_ECS_CLUSTER_NAME}" >> $BASH_ENV
            echo "export AWS_ECS_SERVICE_NAME=${AWS_ECS_SERVICE_NAME}" >> $BASH_ENV
            
            echo "Fetching application secrets from path: ${ENV_PATH}"
            ENV_PARAMS=$(aws ssm get-parameters-by-path --path "${ENV_PATH}" --query "Parameters" --with-decryption)

            # Create the .env file from application secrets
            echo "Creating .env file..."
            echo "$ENV_PARAMS" | jq -r '.[] | .Name |= sub("^(.*)/"; "") | "\(.Name)=\(.Value)"' > .env
            
            echo ".env file created with the following keys:"
            cut -d'=' -f1 .env
            
      # Step 2: Build and Push the Docker image to ECR
      - aws-ecr/build-and-push-image:
          # The aws-ecr orb constructs the full URL from the repo name and AWS account details
          repo: "${ECR_REPOSITORY_NAME}"
          tag: "latest-<< parameters.environment >>-${CIRCLE_SHA1}"

      # Step 3: Force a new deployment in the Fargate service
      - run:
          name: "Deploy to Fargate"
          command: |
            aws ecs update-service --cluster ${AWS_ECS_CLUSTER_NAME} \
              --service ${AWS_ECS_SERVICE_NAME} \
              --force-new-deployment

workflows:
  deploy:
    jobs:
      - build_and_deploy:
          name: deploy-staging
          environment: staging
          <<: *context
          filters:
            branches:
              only:
                - kyle 

      - build_and_deploy:
          name: deploy-production
          environment: production
          <<: *context
          filters:
            branches:
              only:
                - master 